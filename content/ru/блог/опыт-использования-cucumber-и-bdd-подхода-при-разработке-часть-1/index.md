+++
authors = ["snayp"]
categories = ["тестирование", "онлайн"]
date = "2020-11-30T05:10:51+03:00"
draft = false
tags = ["автоматизация", "cucumber", "selenium", "java", "BDD"]
title = "Знакомство Cucumber и BDD и TDD подхода. Начало."

+++

## Знакомство с BDD

{{< figure src="header.png" link="https://cucumber.io/" title="BDD - мнения за и против, best practicies и anti patterns." caption="*Особенности процесса и полезные инструменты позволяющие команде сосредоточиться на реальных примерах использования системы с точки зрения конечного пользователя.*" alt="Behaviour Driven Development (BDD) - командное обсуждение существенных детелей проекта, позволяющее добиться однозначного понимания будущих изменений у всех членов команды." class="small" >}}

О фреймворке [Cucumber](https://cucumber.io/), я узнал, примерно 7 лет назад. Увлечение фреймворком Ruby on Rails первое упоминание гибких методов разработки, сформулированные группой и сразу оценил возможность в 10 строчек написать e2e тест, основанного спеке. Написанной разговорным зяком, до написания и описывающее реальное использование возможностей системы, по всем канонам BDD/TDD подходов. Тест сразу мог запускался в headless версии браузера и только для отладки переключаться на полноценную версию. RoR подразумевает написание большого количества тестов из всех ступеней пирамиды тестирования и развила очень мощный инструментарий для тестов и проверок, которые могут понадобиться 90% создаваемых приложений. Сами принципы, которым рекомендуют следовать абрревиатуры BDD & TDD при организации процесса разработки и которым нужно придерживаются всем членам команды, смогли выразить весь накопленный опыт в программировании полученный при создании сложнейшего ПО, решающего задачи не доступные раньше для человека, изменили отношение к классическим источника дохода и перераспредение ресурсов в пользу цифровых я узнал благодаря передовому взгляду и инновацционному отношениею к процессам в командах, заинтересованных получить инструмент для оптимизации и упрощения издержен бизнеса и увеличить прибыль компании. Затраты на внедрение этих правил и рекомендаций, в несколько раз окупятся в долгосрочном проекте, в первый год развития. Неизменно следовать основым идеям, позволит получить максимальную уверенность в качестве и правильной работоспосоюности всего реализованного функционала, который описан и задокументирован разговорным языком в объеме достаточном для понимая всей доступной логики.

При первом знакомстве с гибкими подходами в разработке, приносящими множество улучшений в команде, которые позволят иметь единое представление у всех участников, о функциях и параметрах которые появятся, в будующем, через значительный промежок времени. Но и без этого же мы создавали надежное ПО для гигантских вычислений? Перспективы техник не были , в 2016 года в отечественной разработке массого использования не оценить по достуинству возможности предлагаемыми BDD & TDD методологиями и начать их применять на практике. Сразу стоит оговориться, что до сих пор споры на тему применимости данных подходов и реального профита для команды, не утихли и продожаются среди сторонников и противников в среде тестировщиков-автоматизаторов.

В следующий раз я столкнулся с синтаксисом Given, When, Then уже при написании тестов на REST API используя Java и библиотеку [Rest-Assured](http://rest-assured.io/). Тесты выглядели примерно так и кроме  синтаксиса от BDD не заимствовали ничего лишнего.

{{< gist snayp c41875f9b2aa729ee29b32e13cc5205c >}}

[Выложил больше примеров с описанием, что делают тесты](https://automated-testing.info/t/code-recipe-primer-ispolzovaniya-rest-assured-dlya-avtomatizaczii-restfull-api/24599?u=snayp)

Затем, при автоматизации Websocket API пришлось использовать JavaScript инструменты - [Jasmine](https://jasmine.github.io/) + [Karma](https://karma-runner.github.io/latest/index.html). Jasmine - BDD фреймворк, который "из коробки" имеет все необходимое для тестировани JavaScript кода. Не зависит ни каких сторонних npm модулей, потому очень шустрый. В моем случае, он был очень удобен по двум причинам:

- для тестирования ассинхронного WebSocket API JavaScript оказался гораздо приспособленней, чем Java;
- парсить JSON объекты JavaScript'ом, намного легче, чем возиться с Java объектами;

Возможности BDD, снова никакой роли не играли. Тут хочу мельком сказать про свое первое знакомство с магией Promise, Поскольку тесты подразумевали несколько последовательных вызовов API, где каждый последующий вызов использовал результаты предыдущего, то очень быстро код стал абсолютно не читаемым из-за огромного числа вложенных callback'ов.

{{< highlight javascript >}}
wsApi.sendMessage("service", "linktourist", linkQuery, function (data) {
    wsApi.sendMessage("service", "unlinktourist", linkQuery, function (data) {
        wsApi.sendMessage("person", "delete", {id: personId}, function (data) {
            wsApi.sendMessage("service", "delete", {service: serviceId}, function (data) {
                wsApi.sendMessage("order", "delete", {id: orderId}, function (data) {
                    done();
                });
            });
        });
    });
});
{{< /highlight >}}

Хоть IntelliJIDEA и мощнейший редактор текста, но искать, где же пропущена одна скобка или точка с зяпятой, было просто не выносимо. Тогда я первый раз узнал про Linter'ы, это тоже отдельная тема, которой будет посвящен пост в будущем. Сокральный смысл Promise я тогда не понял, а вот возможность отрефакторить код, чтобы он был выровнен по левому краю, оценил сразу!

{{< highlight javascript >}}
it("dry cleaning", function(done) {
        var inDate = new Date().getTime() + 60 * 60 * 24 * 40 * 1000;
        var outDate = new Date().getTime() + 60 * 60 * 24 * 40 * 1000;
        var searchQuery = {
            place: {
                in: "HO000288TR"
            },
            date: {
                in: inDate,
                out: outDate,
                intime: 43200000, // 12:00
                outtime: 50400000 // 14:00
            },
            families: [
                {
                    adults: 2
                }
            ]
        };
 {
                expect(data).not.toBeNull();
                expect(data.extras).not.toBeNull();
                expect(data.extras.length).toBeGreaterThan(0);
                expect(data.extras.length).toBe(1);

                var extra = data.extras[0];
                expect(extra.type).not.toBeNull();
                expect(extra.type).toBe("DRY");
                expect(extra.index).not.toBeNull();
                expect(extra.index).toBe(0);
                expect(extra.commerce.offer).toBe(context.extraOffer);
                expect(extra.commerce.original).not.toBeNull();
                expect(extra.commerce.payment).not.toBeNull();
                expect(extra.commerce.currency).not.toBeNull();
                expect(extra.commerce.currency).toBe(978);

                done();
            });
        };
        
        paginationQuery(searchQuery);
    }, 20000);
});
{{< /highlight >}}

Итого, за первые 5 лет моего знакомства с термином Behaviour Driven Development (BDD), так и не возникло насущной необходимости, благодаря который я бы смог подробнее разобраться, зачем же еще что то новое придумали и смог бы применить новый подход в своей работе.

В следующей части будет рассказ, о том, как же я все таки осознал, как и зачем можно использовать BDD и даже нашел задачу, где предложенные методы, могли реально упростить разработку, а точнее, что описание конкретного кейса на естественном языке, действительно помогает понять смысл разрабатываемого функционала всем членам команды и не тратить ресуры на реализацию сомнительнего функционала.
